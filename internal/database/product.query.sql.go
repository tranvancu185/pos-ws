// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: product.query.sql

package database

import (
	"context"
	"database/sql"
)

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (product_name, product_code, product_description, product_price, product_status, product_properties) VALUES (?, ?, ?, ?, ?, ?)
RETURNING product_id
`

type CreateProductParams struct {
	ProductName        string         `json:"product_name"`
	ProductCode        string         `json:"product_code"`
	ProductDescription sql.NullString `json:"product_description"`
	ProductPrice       int64          `json:"product_price"`
	ProductStatus      int64          `json:"product_status"`
	ProductProperties  sql.NullString `json:"product_properties"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createProduct,
		arg.ProductName,
		arg.ProductCode,
		arg.ProductDescription,
		arg.ProductPrice,
		arg.ProductStatus,
		arg.ProductProperties,
	)
	var product_id int64
	err := row.Scan(&product_id)
	return product_id, err
}

const deleteProductByID = `-- name: DeleteProductByID :exec
UPDATE products
SET deleted_at = ?,
    product_status = 2,
    updated_at = ?
WHERE product_id = ?
`

type DeleteProductByIDParams struct {
	DeletedAt sql.NullInt64 `json:"deleted_at"`
	UpdatedAt sql.NullInt64 `json:"updated_at"`
	ProductID int64         `json:"product_id"`
}

func (q *Queries) DeleteProductByID(ctx context.Context, arg DeleteProductByIDParams) error {
	_, err := q.db.ExecContext(ctx, deleteProductByID, arg.DeletedAt, arg.UpdatedAt, arg.ProductID)
	return err
}

const forceDeleteProductByID = `-- name: ForceDeleteProductByID :exec
DELETE FROM products
WHERE product_id = ? OR product_code = ?
`

type ForceDeleteProductByIDParams struct {
	ProductID   int64  `json:"product_id"`
	ProductCode string `json:"product_code"`
}

func (q *Queries) ForceDeleteProductByID(ctx context.Context, arg ForceDeleteProductByIDParams) error {
	_, err := q.db.ExecContext(ctx, forceDeleteProductByID, arg.ProductID, arg.ProductCode)
	return err
}

const getListProducts = `-- name: GetListProducts :many
SELECT product_id, product_code, product_name, product_description, product_price, product_status, product_properties 
FROM products 
WHERE product_id = ? 
    AND product_code = ? 
    AND product_status = ? 
    AND (created_at >= ? AND created_at <= ?) 
    AND (deleted_at >= ? AND deleted_at <= ?)
ORDER BY ?
LIMIT ? 
OFFSET ?
`

type GetListProductsParams struct {
	ProductID     int64         `json:"product_id"`
	ProductCode   string        `json:"product_code"`
	ProductStatus int64         `json:"product_status"`
	CreatedAt     sql.NullInt64 `json:"created_at"`
	CreatedAt_2   sql.NullInt64 `json:"created_at_2"`
	DeletedAt     sql.NullInt64 `json:"deleted_at"`
	DeletedAt_2   sql.NullInt64 `json:"deleted_at_2"`
	Limit         int64         `json:"limit"`
	Offset        int64         `json:"offset"`
}

type GetListProductsRow struct {
	ProductID          int64          `json:"product_id"`
	ProductCode        string         `json:"product_code"`
	ProductName        string         `json:"product_name"`
	ProductDescription sql.NullString `json:"product_description"`
	ProductPrice       int64          `json:"product_price"`
	ProductStatus      int64          `json:"product_status"`
	ProductProperties  sql.NullString `json:"product_properties"`
}

func (q *Queries) GetListProducts(ctx context.Context, arg GetListProductsParams) ([]GetListProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, getListProducts,
		arg.ProductID,
		arg.ProductCode,
		arg.ProductStatus,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.DeletedAt,
		arg.DeletedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetListProductsRow
	for rows.Next() {
		var i GetListProductsRow
		if err := rows.Scan(
			&i.ProductID,
			&i.ProductCode,
			&i.ProductName,
			&i.ProductDescription,
			&i.ProductPrice,
			&i.ProductStatus,
			&i.ProductProperties,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductByCategoryID = `-- name: GetProductByCategoryID :many
SELECT product_id, product_name, product_code, product_description, product_price, product_status, product_properties FROM products WHERE product_category_id = ? ORDER BY ? LIMIT ?
`

type GetProductByCategoryIDParams struct {
	ProductCategoryID int64 `json:"product_category_id"`
	Limit             int64 `json:"limit"`
}

type GetProductByCategoryIDRow struct {
	ProductID          int64          `json:"product_id"`
	ProductName        string         `json:"product_name"`
	ProductCode        string         `json:"product_code"`
	ProductDescription sql.NullString `json:"product_description"`
	ProductPrice       int64          `json:"product_price"`
	ProductStatus      int64          `json:"product_status"`
	ProductProperties  sql.NullString `json:"product_properties"`
}

func (q *Queries) GetProductByCategoryID(ctx context.Context, arg GetProductByCategoryIDParams) ([]GetProductByCategoryIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductByCategoryID, arg.ProductCategoryID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductByCategoryIDRow
	for rows.Next() {
		var i GetProductByCategoryIDRow
		if err := rows.Scan(
			&i.ProductID,
			&i.ProductName,
			&i.ProductCode,
			&i.ProductDescription,
			&i.ProductPrice,
			&i.ProductStatus,
			&i.ProductProperties,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductByCode = `-- name: GetProductByCode :one
SELECT product_id, product_name, product_code, product_description, product_price, product_status, product_properties FROM products WHERE product_code = ?
`

type GetProductByCodeRow struct {
	ProductID          int64          `json:"product_id"`
	ProductName        string         `json:"product_name"`
	ProductCode        string         `json:"product_code"`
	ProductDescription sql.NullString `json:"product_description"`
	ProductPrice       int64          `json:"product_price"`
	ProductStatus      int64          `json:"product_status"`
	ProductProperties  sql.NullString `json:"product_properties"`
}

func (q *Queries) GetProductByCode(ctx context.Context, productCode string) (GetProductByCodeRow, error) {
	row := q.db.QueryRowContext(ctx, getProductByCode, productCode)
	var i GetProductByCodeRow
	err := row.Scan(
		&i.ProductID,
		&i.ProductName,
		&i.ProductCode,
		&i.ProductDescription,
		&i.ProductPrice,
		&i.ProductStatus,
		&i.ProductProperties,
	)
	return i, err
}

const getProductByID = `-- name: GetProductByID :one
SELECT product_id, product_name, product_code, product_description, product_price, product_status, product_properties FROM products WHERE product_id = ?
`

type GetProductByIDRow struct {
	ProductID          int64          `json:"product_id"`
	ProductName        string         `json:"product_name"`
	ProductCode        string         `json:"product_code"`
	ProductDescription sql.NullString `json:"product_description"`
	ProductPrice       int64          `json:"product_price"`
	ProductStatus      int64          `json:"product_status"`
	ProductProperties  sql.NullString `json:"product_properties"`
}

func (q *Queries) GetProductByID(ctx context.Context, productID int64) (GetProductByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getProductByID, productID)
	var i GetProductByIDRow
	err := row.Scan(
		&i.ProductID,
		&i.ProductName,
		&i.ProductCode,
		&i.ProductDescription,
		&i.ProductPrice,
		&i.ProductStatus,
		&i.ProductProperties,
	)
	return i, err
}

const restoreProductByID = `-- name: RestoreProductByID :exec
UPDATE products
SET deleted_at = 0,
    product_status = 0,
    updated_at = ?
WHERE product_id = ?
`

type RestoreProductByIDParams struct {
	UpdatedAt sql.NullInt64 `json:"updated_at"`
	ProductID int64         `json:"product_id"`
}

func (q *Queries) RestoreProductByID(ctx context.Context, arg RestoreProductByIDParams) error {
	_, err := q.db.ExecContext(ctx, restoreProductByID, arg.UpdatedAt, arg.ProductID)
	return err
}

const searchProducts = `-- name: SearchProducts :many
SELECT product_id, product_name, product_code, product_description, product_price, product_status, product_properties 
FROM products 
WHERE product_status = 1 
    AND (product_id = ? OR product_name LIKE ? OR product_code LIKE ?)
ORDER BY ? 
LIMIT ? 
OFFSET ?
`

type SearchProductsParams struct {
	ProductID   int64  `json:"product_id"`
	ProductName string `json:"product_name"`
	ProductCode string `json:"product_code"`
	Limit       int64  `json:"limit"`
	Offset      int64  `json:"offset"`
}

type SearchProductsRow struct {
	ProductID          int64          `json:"product_id"`
	ProductName        string         `json:"product_name"`
	ProductCode        string         `json:"product_code"`
	ProductDescription sql.NullString `json:"product_description"`
	ProductPrice       int64          `json:"product_price"`
	ProductStatus      int64          `json:"product_status"`
	ProductProperties  sql.NullString `json:"product_properties"`
}

func (q *Queries) SearchProducts(ctx context.Context, arg SearchProductsParams) ([]SearchProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchProducts,
		arg.ProductID,
		arg.ProductName,
		arg.ProductCode,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchProductsRow
	for rows.Next() {
		var i SearchProductsRow
		if err := rows.Scan(
			&i.ProductID,
			&i.ProductName,
			&i.ProductCode,
			&i.ProductDescription,
			&i.ProductPrice,
			&i.ProductStatus,
			&i.ProductProperties,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProductByID = `-- name: UpdateProductByID :exec
UPDATE products
SET product_name = ?,
    product_code = ?,
    product_description = ?,
    product_price = ?,
    product_status = ?,
    product_properties = ?,
    updated_at = ?
WHERE product_id = ?
`

type UpdateProductByIDParams struct {
	ProductName        string         `json:"product_name"`
	ProductCode        string         `json:"product_code"`
	ProductDescription sql.NullString `json:"product_description"`
	ProductPrice       int64          `json:"product_price"`
	ProductStatus      int64          `json:"product_status"`
	ProductProperties  sql.NullString `json:"product_properties"`
	UpdatedAt          sql.NullInt64  `json:"updated_at"`
	ProductID          int64          `json:"product_id"`
}

func (q *Queries) UpdateProductByID(ctx context.Context, arg UpdateProductByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateProductByID,
		arg.ProductName,
		arg.ProductCode,
		arg.ProductDescription,
		arg.ProductPrice,
		arg.ProductStatus,
		arg.ProductProperties,
		arg.UpdatedAt,
		arg.ProductID,
	)
	return err
}

const updateProductStatusByID = `-- name: UpdateProductStatusByID :exec
UPDATE products
SET product_status = ?,
    updated_at = ?
WHERE product_id = ?
`

type UpdateProductStatusByIDParams struct {
	ProductStatus int64         `json:"product_status"`
	UpdatedAt     sql.NullInt64 `json:"updated_at"`
	ProductID     int64         `json:"product_id"`
}

func (q *Queries) UpdateProductStatusByID(ctx context.Context, arg UpdateProductStatusByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateProductStatusByID, arg.ProductStatus, arg.UpdatedAt, arg.ProductID)
	return err
}
